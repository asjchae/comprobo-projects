--- Mobile Robotics Project ---
by Ari Chae and Sharon Grimshaw
10/14/2014 Computational Robotics

1. What was the goal of your project?
We decided to build our own project off the concept of learning by demonstration. Our goal was to teach the NEATO using supervised learning to deal with various obstacles. For our MVP, we wanted it to be able to learn how to approach a wall and stop.

2. How did you solve the problem?
The first step was to show the robot what we wanted it to do. We wrote a data collection script to save tuples of laser scan data and velocity data, and then used teleop to slow down the robot as it approached a wall (the behavior we wanted it to learn). We saved that data to a pickle file and then used linear regression to find the constant that best approximated our data. Then we used that constant to have the robot approach the wall on its own, slowing down and coming to a stop as it neared it.

3. Describe a design decision you had to make when working on your project and what you ultimately did and why.
We had to decide how to store the laser scan training data that we would be using in the linear regression. Ultimately, we decided to use a pickle file over a database. We didn't have enough data to warrant setting up a database and it was much less complicated to just dump to a pickle file. Before making this decision, we first tested the speed at which we could pickle data to make sure that it wouldn't impact our data collection. When we saw that it was both less complicated to pickle the data and that the data would pickle fast enough, we chose to push forward with pickling instead of using a database.

4. How did you structure your code?
We split our code into three parts - a data collection script, a linear regression script, and a robot moving script. The data collection script (data_collect.py) collected and saved laser scan data and velocity data while we were driving the NEATO using teleop. At the end, it pickled all the data. The linear regression script (unpacker.py) uses Ridge from scikit-learn's linear_model package to find a best-fit line for the velocity based on which laser scan the robot sees and saves this information in a Ridge object into a second pickle file. The robot mover script (move_robot.py) takes a laser scan of where the NEATO is currently, uses the constant derived from the linear regression, and chooses how fast the robot should be moving at that time.

5. What (if any) challenges did you face along the way?
Our first challenge was learning how to save the laser scan and velocity data in a way that would be meaningful for us. We decided to average different sections of the laser scan for more accurate readings, and we saved the Twist messages and determined which parts of the Twist message were most important. The biggest challenge was to learn enough about machine learning to teach the robot how we wanted it to move. We learned how to use a linear regression in the linear_model package of scikit-learn and used the constant to train the robot. Another challenge was to understand the data that we were getting. The output of the Ridge function is a Ridge object and we had to learn how to access the data that we wanted so that we could teach the robot how to move.

6. What would you do to improve your project if you had more time?
The next step would be to add the ability to sense obstacles in different orientations (other than directly in front of the robot). For instance, if there are two obstacles that are on either side of the robot, the robot should know to go in between them. This addition would also include the ability to turn to avoid obstables. We decided to focus on linear movement (instead of angular movement) for our MVP, but we could definitely do more with the different directions the NEATO is capable of moving in. We also opted to focus on the area directly in front of the robot to limit the amount of data we were dealing with, but given more time we would take into account all of the laser scan information we have.

7. Did you learn any interesting lessons for future robotic programming projects? (ex: teaming, open-ended projects, longer-term goals, etc.)
The big insight that we will take forward is to build code in small pieces. We started by building code in large chunks and not doing much testing, but this made debugging much more challenging later. We also found that having both of us debugging together made debugging go faster as opposed to one person staring at the code on their own. We also think that we were overly ambitious when we first started planning the project, and it made us disappointed when we couldn't work fast enough to make the robot do cool things.